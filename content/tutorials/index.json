[{"uri":"https://fslab.org/advanced-placeholder.html","title":"WIP\n","content":"(***hide***)\n\n(*\n#frontmatter\n---\ntitle: Advanced placeholder\ncategory: advanced\nauthors: won\u0027t tell\nindex: 0\n---\n*)\n\n(**\n# WIP\n*)"},{"uri":"https://fslab.org/002_clustering_kMeans.html","title":"Clustering with FSharp.Stats I: k-means\n","content":"(***hide***)\n\n(*\n#frontmatter\n---\ntitle: Clustering with FSharp.Stats I: k-means\ncategory: datascience\nauthors: Benedikt Venn\nindex: 1\n---\n*)\n\n(***condition:prepare***)\n#r \u0022nuget: Deedle\u0022\n#r \u0022nuget: FSharp.Stats\u0022\n#r \u0022nuget: Newtonsoft.JSON\u0022\n#r \u0022nuget: Plotly.NET, 2.0.0-preview.6\u0022\n#r \u0022nuget: FSharp.Data\u0022\n\n(***condition:ipynb***)\n#if IPYNB\n#r \u0022nuget: Deedle\u0022\n#r \u0022nuget: FSharp.Stats\u0022\n#r \u0022nuget: Newtonsoft.JSON\u0022\n#r \u0022nuget: Plotly.NET, 2.0.0-preview.6\u0022\n#r \u0022nuget: Plotly.NET.Interactive, 2.0.0-preview.6\u0022\n#r \u0022nuget: FSharp.Data\u0022\n#endif // IPYNB\n\n(**\n\n[![Binder]({{root}}images/badge-binder.svg)](https://mybinder.org/v2/gh/fslaborg/fslaborg.github.io/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script]({{root}}images/badge-script.svg)]({{root}}content/tutorials/{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook]({{root}}images/badge-notebook.svg)]({{root}}content/tutorials/{{fsdocs-source-basename}}.ipynb)\n\n\n# Clustering with FSharp.Stats I: k-means\n\n_Summary:_ This tutorial demonstrates k means clustering with FSharp.Stats and how to visualize the results with Plotly.NET.\n\n## Introduction\n\nClustering methods can be used to group elements of a huge data set based on their similarity. Elements sharing similar properties cluster together and can be reported as coherent group.\nk-means clustering is a frequently used technique, that segregates the given data into k clusters with similar elements grouped in each cluster, but high variation between the clusters.\nThe algorithm to cluster a n-dimensional dataset can be fully described in the following 4 steps:\n\n  1. Initialize k n-dimensional centroids, that are randomly distributed over the data range.\n  2. Calculate the distance of each point to all centroids and assign it to the nearest one.\n  3. Reposition all centroids by calculating the average point of each cluster.\n  4. Repeat step 2-3 until convergence.\n\n### Centroid initiation\n\nSince the random initiation of centroids may influences the result, a second initiation algorithm is proposed (_cvmax_), that extract a set of medians from the dimension with maximum variance to initialize the centroids. \n\n### Distance measure\n\nWhile several distance metrics can be used (e.g. Manhattan distance or correlation measures) it is preferred to use Euclidean distance.\nIt is recommended to use a squared Euclidean distance. To not calculate the square root does not change the result but saves computation time.\n\n\u003Ccenter\u003E\n\u003Cimg style=\u0022max-width:75%\u0022 src=\u0022../../images/kMeans.png\u0022 class=\u0022center\u0022\u003E\u003C/img\u003E\n\u003C/center\u003E\n\u003Cbr\u003E\n\n\nFor demonstration of k-means clustering, the classic iris data set is used, which consists of 150 records, each of which contains four measurements and a species identifier.\n\n## Referencing packages\n\n\u0060\u0060\u0060fsharp\n// Packages hosted by the Fslab community\n#r \u0022nuget: Deedle\u0022\n#r \u0022nuget: FSharp.Stats\u0022\n// third party .net packages \n#r \u0022nuget: Plotly.NET, 2.0.0-preview.6\u0022\n#r \u0022nuget: Plotly.NET.Interactive, 2.0.0-preview.6\u0022\n#r \u0022nuget: FSharp.Data\u0022\n\u0060\u0060\u0060\n\n*)\n\n(**\n## Loading data\n*)\nopen FSharp.Data\nopen Deedle\n\n// Retrieve data using the FSharp.Data package and read it as dataframe using the Deedle package\nlet rawData = Http.RequestString @\u0022https://raw.githubusercontent.com/fslaborg/datasets/main/data/iris.csv\u0022\nlet df = Frame.ReadCsvString(rawData)\n\ndf.Print()\n\n(*** include-output ***)\n\n(**\n\nLet\u0027s take a first look at the data with heatmaps using Plotly.NET. Each of the 150 records consists of four measurements and a species identifier. \nSince the species identifier occur several times (_Iris-virginica_, _Iris-versicolor_, and _Iris-setosa_), we create unique labels by adding the rows index to the species identifier.\n\n*)\nopen Plotly.NET\n\nlet colNames = [\u0022sepal_length\u0022;\u0022sepal_width\u0022;\u0022petal_length\u0022;\u0022petal_width\u0022]\n\n// isolate data as float [] []\nlet data = \n    Frame.dropCol \u0022species\u0022 df\n    |\u003E Frame.toJaggedArray\n\n//isolate labels as seq\u003Cstring\u003E\nlet labels = \n    Frame.getCol \u0022species\u0022 df\n    |\u003E Series.values\n    |\u003E Seq.mapi (fun i s -\u003E sprintf \u0022%s_%i\u0022 s i)\n\nlet dataChart = \n    Chart.Heatmap(data,ColNames=colNames,RowNames=labels)\n    // required to fit the species identifier on the left side of the heatmap\n    |\u003E Chart.withMarginSize(Left=100.)\n    |\u003E Chart.withTitle \u0022raw iris data\u0022\n\n// required to fit the species identifier on the left side of the heatmap\n(**\u003Ccenter\u003E*)\n(*** condition: ipynb ***)\n#if IPYNB\ndataChart\n#endif // IPYNB\n\n(***hide***)\ndataChart |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\n\u003C/center\u003E\n## Clustering\n\nThe function that performs k-means clustering can be found at \u0060FSharp.Stats.ML.Unsupervised.IterativeClustering.kmeans\u0060. It requires four input parameters:\n\n  1. Centroid initiation method\n  2. Distance measure (from \u0060FSharp.Stats.ML.DistanceMetrics\u0060)\n  3. Data to cluster as \u0060float [] []\u0060, where each entry of the outer array is a sequence of coordinates\n  4. _k_, the number of clusters that are desired\n\n\n*)\n\nopen FSharp.Stats\nopen FSharp.Stats.ML\nopen FSharp.Stats.ML.Unsupervised\n\n// For random cluster initiation use randomInitFactory:\nlet rnd = System.Random()\nlet randomInitFactory : IterativeClustering.CentroidsFactory\u003Cfloat []\u003E = \n    IterativeClustering.randomCentroids\u003Cfloat []\u003E rnd\n\n// For assisted cluster initiation use cvmaxFactory:\n//let cvmaxFactory : IterativeClustering.CentroidsFactory\u003Cfloat []\u003E = \n//    IterativeClustering.intitCVMAX\n\nlet distanceFunction = DistanceMetrics.euclideanNaNSquared\n  \nlet kmeansResult = \n    IterativeClustering.kmeans distanceFunction randomInitFactory data 4\n\n\n(**\nAfter all centroids are set, the affiliation of a datapoint to a cluster can be determined by minimizing the distance of the respective point to each of the centroids.\nA function realizing the mapping is integrated in the \u0060kmeansResult\u0060.\n\n*)\n\nlet clusteredIrisData =\n    Seq.zip labels data\n    |\u003E Seq.map (fun (species,dataPoint) -\u003E \n        let clusterIndex,centroid = kmeansResult.Classifier dataPoint\n        clusterIndex,species,dataPoint)\n\n// Each datapoint is given associated with its cluster index, species identifier, and coordinates.\n\n(*** condition: ipynb ***)\n#if IPYNB\nclusteredIrisData\n|\u003E Seq.take 10\n|\u003E Seq.map (fun (a,b,c) -\u003E sprintf \u0022%i, %A, %A\u0022 a b c)\n|\u003E String.concat \u0022\\n\u0022\n|\u003E String.concat \u0022\u003Cbr\u003E\u0022\n|\u003E fun x -\u003E x \u002B \u0022\u003Cbr\u003E ... \u0022\n#endif // IPYNB\n\n(***hide***)\nlet printClusters=\n    clusteredIrisData\n    |\u003E Seq.take 7\n    |\u003E Seq.map (fun (a,b,c) -\u003E sprintf \u0022%i, %A, %A\u0022 a b c)\n    |\u003E String.concat \u0022\\n\u0022\n    |\u003E fun x -\u003E x \u002B \u0022\\n ... \u0022\n\n(*** include-value:printClusters ***)\n(**\n\n## Visualization of the clustering result as heatmap\n\nThe datapoints are sorted according to their associated cluster index and visualized in a combined heatmap.\n*)\n\nlet clusterChart =\n    clusteredIrisData\n    //sort all data points according to their assigned cluster number\n    |\u003E Seq.sortBy (fun (clusterIndex,label,dataPoint) -\u003E clusterIndex)\n    |\u003E Seq.unzip3\n    |\u003E fun (_,labels,d) -\u003E \n        Chart.Heatmap(d,ColNames=colNames,RowNames=labels)\n        // required to fit the species identifier on the left side of the heatmap\n        |\u003E Chart.withMarginSize(Left=100.)\n        |\u003E Chart.withTitle \u0022clustered iris data (k-means clustering)\u0022\n(**\n\u003Ccenter\u003E\n*)\n(*** condition: ipynb ***)\n#if IPYNB\nclusterChart\n#endif // IPYNB\n\n(***hide***)\nclusterChart |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\n\u003C/center\u003E\n\nTo visualize the result in a three-dimensional chart, three of the four measurements are isolated after clustering and visualized as 3D-scatter plot.\n\n*)\n\nlet clusterChart3D =\n    //group clusters\n    clusteredIrisData\n    |\u003E Seq.groupBy (fun (clusterIndex,label,dataPoint) -\u003E clusterIndex)\n    //for each cluster generate a scatter plot\n    |\u003E Seq.map (fun (clusterIndex,cluster) -\u003E \n        cluster\n        |\u003E Seq.unzip3\n        |\u003E fun (clusterIndex,label,data) -\u003E \n            let clusterName = sprintf \u0022cluster %i\u0022 (Seq.head clusterIndex)\n            //for 3 dimensional representation isolate sepal length, petal length, and petal width\n            let truncData = data |\u003E Seq.map (fun x -\u003E x.[0],x.[2],x.[3]) \n            Chart.Scatter3d(truncData,mode=StyleParam.Mode.Markers,Name = clusterName,Labels=label)\n        )\n    |\u003E Chart.Combine\n    |\u003E Chart.withTitle \u0022isolated coordinates of clustered iris data (k-means clustering)\u0022\n    |\u003E Chart.withX_AxisStyle colNames.[0]\n    |\u003E Chart.withY_AxisStyle colNames.[2]\n    |\u003E Chart.withZ_AxisStyle colNames.[3]\n\n(**\n\u003Ccenter\u003E\n*)\n(*** condition: ipynb ***)\n#if IPYNB\nclusterChart3D\n#endif // IPYNB\n\n(***hide***)\nclusterChart3D |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\n\u003C/center\u003E\n\n### Optimal cluster number\n\nThe identification of the optimal cluster number _k_ in terms of the average squared distance of each point to its centroid \ncan be realized by performing the clustering over a range of _k_\u0027s multiple times and taking the _k_ according to the elbow criterion.\nFurther more robust and advanced cluster number determination techniques can be found [here](https://fslab.org/FSharp.Stats/Clustering.html#Determining-the-optimal-number-of-clusters).\n\n*)\n\nlet getBestkMeansClustering bootstraps k =\n    let dispersions =\n        Array.init bootstraps (fun _ -\u003E \n            IterativeClustering.kmeans distanceFunction randomInitFactory data k\n            )\n        |\u003E Array.map (fun clusteringResult -\u003E IterativeClustering.DispersionOfClusterResult clusteringResult)\n    Seq.mean dispersions,Seq.stDev dispersions\n\nlet iterations = 10\n\nlet maximalK = 10\n\nlet bestKChart = \n    [2 .. maximalK] \n    |\u003E List.map (fun k -\u003E \n        let mean,stdev = getBestkMeansClustering iterations k\n        k,mean,stdev\n        )\n    |\u003E List.unzip3\n    |\u003E fun (ks,means,stdevs) -\u003E \n        Chart.Line(ks,means)\n        |\u003E Chart.withYErrorStyle(stdevs)\n        |\u003E Chart.withX_AxisStyle \u0022k\u0022\n        |\u003E Chart.withY_AxisStyle \u0022average dispersion\u0022\n        |\u003E Chart.withTitle \u0022iris data set average dispersion per k\u0022\n(**\n\u003Ccenter\u003E\n*)\n(*** condition: ipynb ***)\n#if IPYNB\nbestKChart\n#endif // IPYNB\n\n(***hide***)\nbestKChart |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\n\n\u003C/center\u003E\n\n## Limitations\n\n  1. Outlier have a strong influence on the positioning of the centroids. \n  2. Determining the correct number of clusters in advance is critical. Often it is chosen according to the number of classes present in the dataset which isn\u0027t in the spirit of clustering procedures.\n\n## Notes\n\n  - Please note that depending on what data you want to cluster, a column wise z-score normalization may be required. In the presented example differences in sepal width have a reduced influence because\n  the absolute variation is low.\n\n## References\n\n  - FSharp.Stats documentation, fslaborg, https://fslab.org/FSharp.Stats/Clustering.html\n  - Shraddha and Saganna, A Review On K-means Data Clustering Approach, International Journal of Information \u0026 Computation Technology, Vol:4 No:17, 2014\n  - Moth\u0027d Belal, A New Algorithm for Cluster Initialization, International Journal of Computer and Information Engineering, Vol:1 No:4, 2007\n  - Singh et al., K-means with Three different Distance Metrics, International Journal of Computer Applications, 2013, DOI:10.5120/11430-6785\n  - Kodinariya and Makwana, Review on Determining of Cluster in K-means Clustering, International Journal of Advance Research in Computer Science and Management Studies, 2013\n\n## Further reading\n  \nExamples are taken from [FSharp.Stats documentation](https://fslab.org/FSharp.Stats/Clustering.html) that covers various techniques for an optimal cluster number determination.\n  \nThe next article in this series covers [hierarchical clustering using FSharp.Stats](https://fslab.org/content/tutorials/003_clustering_hierarchical.html).\n\n*)\n\n\n"},{"uri":"https://fslab.org/003_clustering_hierarchical.html","title":"Clustering with FSharp.Stats II: hierarchical clustering\n","content":"(***hide***)\n\n(*\n#frontmatter\n---\ntitle: Clustering with FSharp.Stats II: hierarchical clustering\ncategory: datascience\nauthors: Benedikt Venn\nindex: 2\n---\n*)\n\n(***condition:prepare***)\n#r \u0022nuget: Deedle\u0022\n#r \u0022nuget: FSharp.Stats\u0022\n#r \u0022nuget: Newtonsoft.JSON\u0022\n#r \u0022nuget: Plotly.NET, 2.0.0-preview.6\u0022\n#r \u0022nuget: FSharp.Data\u0022\n\n(***condition:ipynb***)\n#if IPYNB\n#r \u0022nuget: Deedle\u0022\n#r \u0022nuget: FSharp.Stats\u0022\n#r \u0022nuget: Newtonsoft.JSON\u0022\n#r \u0022nuget: Plotly.NET, 2.0.0-preview.6\u0022\n#r \u0022nuget: Plotly.NET.Interactive, 2.0.0-preview.6\u0022\n#r \u0022nuget: FSharp.Data\u0022\n#endif // IPYNB\n\n\n(**\n\n[![Binder]({{root}}images/badge-binder.svg)](https://mybinder.org/v2/gh/fslaborg/fslaborg.github.io/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script]({{root}}images/badge-script.svg)]({{root}}content/tutorials/{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook]({{root}}images/badge-notebook.svg)]({{root}}content/tutorials/{{fsdocs-source-basename}}.ipynb)\n\n# Clustering with FSharp.Stats II: hierarchical clustering\n\n_Summary:_ This tutorial demonstrates hierarchical clustering with FSharp.Stats and how to visualize the results with Plotly.NET.\n\nIn the previous article of this series [k-means clustering using FSharp.Stats](https://fslab.org/content/tutorials/002_clustering_kMeans.html) was introduced.\n\n## Introduction\n\nClustering methods can be used to group elements of a huge data set based on their similarity. Elements sharing similar properties cluster together and can be reported as coherent group.\nMany clustering algorithms require a predefined cluster number, that has to be provided by the experimenter.\nHierarchical clustering (hClust) does not require such cluster number definition. Instead, hierarchical clustering results in a tree structure, that has a single cluster (node) on its root and recursively splits up into clusters of \nelements that are more similar to each other than to elements of other clusters. For generating multiple clustering results with different number of clusters, \nthe clustering has to performed only once. Subsequently a cluster number can be defined to split up the clustering tree in the desired number of clusters.\nThe clustering tree is often represented as dendrogram.\n\n### There are two types of hClust:\n\n  - Agglomerative (bottom-up): Each data point is in its own cluster and the nearest ones are merged recursively. It is referred as agglomerative hierarchical clustering.\n\n  - Divisive (top-down): All data points are in the same cluster and you divide the cluster into two that are far away from each other.\n\n  - The presented implementation is an agglomerative type.\n\n### Distance measures\n\nThere are several distance metrics, that can be used as distance function. The commonly used one probably is Euclidean distance.\n\n### Linker\n\nWhen the distance between two clusters is calculated, there are several linkage types to choose from:\n\n  - **complete linkage**: maximal pairwise distance between the clusters (prone to break large clusters)\n\n  - **single linkage**: minimal pairwise distance between the clusters (sensitive to outliers)\n\n  - **centroid linkage**: distance between the two cluster centroids\n\n  - **average linkage**: average pairwise distance between the clusters (sensitive to cluster shape and size)\n\n  - **median linkage**: median pairwise distance between the clusters\n\n\u003Ccenter\u003E\n\u003Cimg style=\u0022max-width:85%\u0022 src=\u0022../../images/hClust.png\u0022\u003E\u003C/img\u003E\n\u003C/center\u003E\n\u003Cbr\u003E\n\n\nFor demonstration of hierarchical clustering, the classic iris data set is used, which consists of 150 records, each of which contains four measurements and a species identifier.\n\n## Referencing packages\n\n\u0060\u0060\u0060fsharp\n// Packages hosted by the Fslab community\n#r \u0022nuget: Deedle\u0022\n#r \u0022nuget: FSharp.Stats\u0022\n// third party .net packages \n#r \u0022nuget: Plotly.NET, 2.0.0-preview.6\u0022\n#r \u0022nuget: Plotly.NET.Interactive, 2.0.0-preview.6\u0022\n#r \u0022nuget: FSharp.Data\u0022\n\u0060\u0060\u0060\n\n*)\n\n(**\n## Loading data\n*)\nopen FSharp.Data\nopen Deedle\n\n// Retrieve data using the FSharp.Data package and read it as dataframe using the Deedle package\nlet rawData = Http.RequestString @\u0022https://raw.githubusercontent.com/fslaborg/datasets/main/data/iris.csv\u0022\nlet df = Frame.ReadCsvString(rawData)\n\ndf.Print()\n\n\n(*** include-output ***)\n\n(**\n\nLet\u0027s take a first look at the data with heatmaps using Plotly.NET. Each of the 150 records consists of four measurements and a species identifier. \nSince the species identifier occur several times (Iris-virginica, Iris-versicolor, and Iris-setosa), we create unique labels by adding the rows index to the species identifier.\n\n*)\nopen Plotly.NET\n\nlet colNames = [\u0022sepal_length\u0022;\u0022sepal_width\u0022;\u0022petal_length\u0022;\u0022petal_width\u0022]\n\n// isolate data as float [] []\nlet data = \n    Frame.dropCol \u0022species\u0022 df\n    |\u003E Frame.toJaggedArray\n    \n\n// isolate labels as seq\u003Cstring\u003E\nlet labels = \n    Frame.getCol \u0022species\u0022 df\n    |\u003E Series.values\n    |\u003E Seq.mapi (fun i s -\u003E sprintf \u0022%s_%i\u0022 s i)\n    |\u003E Array.ofSeq\n\nlet dataChart = \n    Chart.Heatmap(data,ColNames=colNames,RowNames=labels)\n    // required to fit the species identifier on the left side of the heatmap\n    |\u003E Chart.withMarginSize(Left=100.)\n    |\u003E Chart.withTitle \u0022raw iris data\u0022\n\n(**\n\u003Ccenter\u003E\n*)\n(*** condition: ipynb ***)\n#if IPYNB\ndataChart\n#endif // IPYNB\n\n(***hide***)\ndataChart |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\n\u003C/center\u003E\n## Clustering\n\nThe function that performs hierarchical clustering can be found at \u0060FSharp.Stats.ML.Unsupervised.HierarchicalClustering.generate\u0060. It requires three input parameters:\n\n  1. Distance measure working on \u0060\u0027T\u0060 (from \u0060FSharp.Stats.ML.DistanceMetrics\u0060)\n  2. Linkage type\n  3. Data to cluster as \u0060\u0027T\u0060\n\n*)\n\nopen FSharp.Stats.ML\nopen FSharp.Stats.ML.Unsupervised\n\nlet distanceMeasure = DistanceMetrics.euclideanNaNSquared\n\nlet linker = HierarchicalClustering.Linker.centroidLwLinker\n\n// calculates the clustering and reports a single root cluster (node), \n// that may recursively contains further nodes\nlet clusterResultH = \n    HierarchicalClustering.generate distanceMeasure linker data\n\n// If a desired cluster number is specified, the following function cuts the cluster according\n// to the depth, that results in the respective number of clusters (here 3). Only leaves are reported.\nlet threeClusters = HierarchicalClustering.cutHClust 3 clusterResultH\n\n(**\n\nEvery cluster leaf contains its raw values and an index that indicates the position of the respective data \npoint in the raw data. The index can be retrieved from leaves using HierarchicalClustering.getClusterId.\n\n*)\n\n// Detailed information for 3 clusters are given\nlet inspectThreeClusters =\n    threeClusters\n    |\u003E List.map (fun cluster -\u003E \n        cluster\n        |\u003E List.map (fun leaf -\u003E \n            labels.[HierarchicalClustering.getClusterId leaf]\n            )\n        )\n\n(*** condition: ipynb ***)\n#if IPYNB\ninspectThreeClusters\n|\u003E List.mapi (fun i x -\u003E \n    let truncCluster = x.[0..4] |\u003E String.concat \u0022; \u0022 \n    sprintf \u0022Cluster%i: [%s ...]\u0022 i truncCluster \n    )\n|\u003E String.concat \u0022\u003Cbr\u003E\u0022\n#endif // IPYNB\n\n(***hide***)\ninspectThreeClusters\n|\u003E List.mapi (fun i x -\u003E \n    let truncCluster = x.[0..4] |\u003E String.concat \u0022; \u0022 \n    sprintf \u0022Cluster%i: [%s ...]\u0022 i truncCluster \n    )\n|\u003E String.concat \u0022\u003Cbr\u003E\u0022\n(*** include-it-raw ***)\n\n(**\n\nTo break up the tree structure but maintain the clustering order, the cluster tree has to be flattened.\n\n*)\n\n// To recursevely flatten the cluster tree into leaves only, use flattenHClust.\n// A leaf list is reported, that does not contain any cluster membership, \n// but is sorted by the clustering result.\nlet hLeaves = \n    clusterResultH\n    |\u003E HierarchicalClustering.flattenHClust\n    \n// Takes the sorted cluster result and reports a tuple of label and data value.\nlet dataSortedByClustering =    \n    hLeaves\n    |\u003E Seq.choose (fun c -\u003E \n        let label  = labels.[HierarchicalClustering.getClusterId c]\n        let values = HierarchicalClustering.tryGetLeafValue c\n        match values with\n        | None -\u003E None\n        | Some x -\u003E Some (label,x)\n        )\n\n(**\n\nThe visualization again is performed using a Plotly.NET heatmap. \n        \n*)\n\nlet hClusteredDataHeatmap = \n    let (hlable,hdata) =\n        dataSortedByClustering\n        |\u003E Seq.unzip\n    Chart.Heatmap(hdata,ColNames=colNames,RowNames=hlable)\n    // required to fit the species identifier on the left side of the heatmap\n    |\u003E Chart.withMarginSize(Left=100.)\n    |\u003E Chart.withTitle \u0022Clustered iris data (hierarchical clustering)\u0022\n(**\n\u003Ccenter\u003E\n*)\n(*** condition: ipynb ***)\n#if IPYNB\nhClusteredDataHeatmap\n#endif // IPYNB\n\n(***hide***)\nhClusteredDataHeatmap |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n\n(**\n\u003C/center\u003E\n\n## Limitations\n\n  1. There is no strong guidance on which distance function and linkage type should be used. It often is chosen arbitrarily according to the user\u0027s experience.\n  2. The visual interpretation of the dendrogram is difficult, since swapping the direction of some bifurcations may totally disturbe the visual impression.\n\n## Notes\n\n  - Please note that depending on what data you want to cluster, a column wise z-score normalization may be required. In the presented example differences in sepal width have a reduced influence because\n  the absolute variation is low.\n\n## References\n\n  - Vijaya et al., A Review on Hierarchical Clustering Algorithms, Journal of Engineering and Applied Sciences, 2017\n  - Rani and Rohil, A Study of Hierarchical Clustering Algorithm, International Journal of Information and Computation Technology, 2013\n  - FSharp.Stats documentation, fslaborg, https://fslab.org/FSharp.Stats/Clustering.html\n\n## Further reading\n\nExamples are taken from [FSharp.Stats documentation](https://fslab.org/FSharp.Stats/Clustering.html) that covers various techniques for an optimal cluster number determination.\n\nThe next article in this series covers [DBSCAN using FSharp.Stats](https://fslab.org/content/tutorials/004_clustering_DBSCAN.html).\n\n*)\n\n\n"},{"uri":"https://fslab.org/external.html","title":"Here is a list of usefull external (non-fslab) F# resources:\n","content":"(***hide***)\n\n(*\n#frontmatter\n---\ntitle: External F# resources\ncategory: fsharp\nauthors: Various\nindex: 0\n---\n*)\n\n(**\n# Here is a list of usefull external (non-fslab) F# resources:\n\n## Learning and documentation\n- Official F# documentation: https://docs.microsoft.com/en-us/dotnet/fsharp/\n- F# module on Microsoft LEARN: https://docs.microsoft.com/en-us/learn/modules/fsharp-first-steps/\n- Website of the F# Software Foundation: https://fsharp.org/\n\n## Blogs \u0026 other content\n- fsharp for fun and profit: https://fsharpforfunandprofit.com/\n- fsharp weekly: https://sergeytihon.com/category/f-weekly/\n\n*)"},{"uri":"https://fslab.org/004_clustering_DBSCAN.html","title":"Clustering with FSharp.Stats III: DBSCAN\n","content":"(***hide***)\n\n(*\n#frontmatter\n---\ntitle: Clustering with FSharp.Stats III: DBSCAN\ncategory: datascience\nauthors: Benedikt Venn\nindex: 2\n---\n*)\n\n(***condition:prepare***)\n#r \u0022nuget: Deedle\u0022\n#r \u0022nuget: FSharp.Stats\u0022\n#r \u0022nuget: Newtonsoft.JSON\u0022\n#r \u0022nuget: Plotly.NET, 2.0.0-preview.6\u0022\n#r \u0022nuget: FSharp.Data\u0022\n\n(***condition:ipynb***)\n#if IPYNB\n#r \u0022nuget: Deedle\u0022\n#r \u0022nuget: FSharp.Stats\u0022\n#r \u0022nuget: Newtonsoft.JSON\u0022\n#r \u0022nuget: Plotly.NET, 2.0.0-preview.6\u0022\n#r \u0022nuget: Plotly.NET.Interactive, 2.0.0-preview.6\u0022\n#r \u0022nuget: FSharp.Data\u0022\n#endif // IPYNB\n\n(**\n\n[![Binder]({{root}}images/badge-binder.svg)](https://mybinder.org/v2/gh/fslaborg/fslaborg.github.io/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script]({{root}}images/badge-script.svg)]({{root}}content/tutorials/{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook]({{root}}images/badge-notebook.svg)]({{root}}content/tutorials/{{fsdocs-source-basename}}.ipynb)\n\n\n# Clustering with FSharp.Stats III: DBSCAN\n\n_Summary:_ This tutorial demonstrates DBSCAN with FSharp.Stats and how to visualize the results with Plotly.NET.\n\nIn the previous article of this series [hierarchical clustering using FSharp.Stats](https://fslab.org/content/tutorials/003_clustering_hierarchical.html) was introduced.\n\n## Introduction\n\nClustering methods can be used to group elements of a huge data set based on their similarity. Elements sharing similar properties cluster together and can be reported as coherent group.\nDensity-Based Spatial Clustering of Applications with Noise (DBSCAN) was developed to identify clusters with similar density and allows the exclusion of noise points.\n\n### Two global parameters have to be defined:\n\n  - **\u03B5 (eps)**: radius in which the neighbourhood of each point is checked \n  - **minPts**: minimal number of data points, that must fall into the neighbourhood of a region to be defined as dense\n\n### Data points are classified as:\n\n  - **Core point**: Within a radius of eps there are more (or equal) data points than minPts present.\n  - **Border point**: Within a radius of eps there are less data points than minPts present, but a core point is within the neighbourhood.\n  - **Noise point**: None of the conditions above apply.\n\n\u003Ccenter\u003E\n\u003Cimg style=\u0022max-width:75%\u0022 src=\u0022../../images/dbscan.png\u0022 class=\u0022center\u0022\u003E\u003C/img\u003E\n\u003C/center\u003E\n\n\u003Cbr\u003E\n\nFor demonstration of DBSCAN, the classic iris data set is used, which consists of 150 records, each of which contains four measurements and a species identifier.\nIn this tutorial we are going to perform DBSCAN on two- and three-dimensional data.\n\n## Referencing packages\n\n\u0060\u0060\u0060fsharp\n// Packages hosted by the Fslab community\n#r \u0022nuget: Deedle\u0022\n#r \u0022nuget: FSharp.Stats\u0022\n// third party .net packages \n#r \u0022nuget: Plotly.NET, 2.0.0-preview.6\u0022\n#r \u0022nuget: Plotly.NET.Interactive, 2.0.0-preview.6\u0022\n#r \u0022nuget: FSharp.Data\u0022\n\u0060\u0060\u0060\n\n*)\n\n(**\n## Loading data\n*)\nopen FSharp.Data\nopen FSharp.Stats\nopen Deedle\n\n// Retrieve data using the FSharp.Data package and read it as dataframe using the Deedle package\nlet rawData = Http.RequestString @\u0022https://raw.githubusercontent.com/fslaborg/datasets/main/data/iris.csv\u0022\nlet df = Frame.ReadCsvString(rawData)\n\ndf.Print()\n\n\n(*** include-output ***)\n\n(**\n\nLet\u0027s take a first look at the data with 2D and 3D scatter plots using Plotly.NET. Each of the 150 records consists of four measurements and a species identifier. \nSince the species identifier occur several times (Iris-virginica, Iris-versicolor, and Iris-setosa), we create unique labels by adding the rows index to the species identifier.\n\n*)\nopen Plotly.NET\nopen FSharp.Stats.ML.Unsupervised\n\nlet header2D = [\u0022petal_length\u0022;\u0022petal_width\u0022]\nlet header3D = [\u0022sepal_length\u0022;\u0022petal_length\u0022;\u0022petal_width\u0022]\n\n//extract petal length and petal width\nlet data2D = \n    Frame.sliceCols header2D df\n    |\u003E Frame.toJaggedArray\n\n//extract sepal length, petal length, and petal width\nlet data3D = \n    Frame.sliceCols header3D df\n    |\u003E Frame.toJaggedArray\n\nlet labels = \n    Frame.getCol \u0022species\u0022 df\n    |\u003E Series.values\n    |\u003E Seq.mapi (fun i s -\u003E sprintf \u0022%s_%i\u0022 s i)\n\nlet rawChart2D =\n    let unzippedData =\n        data2D\n        |\u003E Array.map (fun x -\u003E x.[0],x.[1])\n    Chart.Scatter(unzippedData,mode=StyleParam.Mode.Markers,Labels=labels)\n    |\u003E Chart.withX_AxisStyle header2D.[0]\n    |\u003E Chart.withY_AxisStyle header2D.[1]\n    |\u003E Chart.withTitle \u0022rawChart2D\u0022\n\nlet rawChart3D =\n    let unzippedData =\n        data3D\n        |\u003E Array.map (fun x -\u003E x.[0],x.[1],x.[2])\n    Chart.Scatter3d(unzippedData,mode=StyleParam.Mode.Markers,Labels=labels)\n    |\u003E Chart.withX_AxisStyle header3D.[0]\n    |\u003E Chart.withY_AxisStyle header3D.[1]\n    |\u003E Chart.withZ_AxisStyle header3D.[2]\n    |\u003E Chart.withTitle \u0022rawChart3D\u0022\n\n(**\n\u003Ccenter\u003E\n*)\n(*** condition: ipynb ***)\n#if IPYNB\nrawChart2D\n#endif // IPYNB\n\n(***hide***)\nrawChart2D |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\n\u003Cbr\u003E\n*)\n\n(*** condition: ipynb ***)\n#if IPYNB\nrawChart3D\n#endif // IPYNB\n\n(***hide***)\nrawChart3D |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n\n(**\n\u003C/center\u003E\n## Clustering\n\nThe function that performs DBSCAN can be found at \u0060FSharp.Stats.ML.Unsupervised.DbScan.compute\u0060. It requires four input parameters:\n\n  1. Distance measure (\u0060from FSharp.Stats.ML.DistanceMetrics\u0060) (\u0060seq\u003C\u0027T\u003E -\u003E seq\u003C\u0027T\u003E -\u003E float\u0060)\n  1. minPts (\u0060int\u0060)\n  3. eps (\u0060float\u0060)\n  4. data points as sequence of coordinate sequences (\u0060seq\u003C#seq\u003C\u0027T\u003E\u003E\u0060)\n\nThe clustering result consists of a sequence of noise point coordinates and a sequence of clusters containing all related point coordinates.\n\n*)\nopen FSharp.Stats.ML\nopen FSharp.Stats.ML.Unsupervised\n\n\nlet eps2D = 0.5\nlet eps3D = 0.7\n\nlet minPts = 20\n\nlet result2D = DbScan.compute DistanceMetrics.Array.euclidean minPts eps2D data2D\n\n(***hide***)\nlet printClusters2D = result2D.ToString()\n(*** include-value:printClusters2D ***)\n\nlet result3D = DbScan.compute DistanceMetrics.Array.euclidean minPts eps3D data3D\n\n(***hide***)\nlet printClusters3D = result3D.ToString()\n\n(*** include-value:printClusters3D ***)\n\n(**\n## Visualization of clustering result\n\nTo visualize the clustering result coordinates of each cluster and noise points are visualized separately and combined in a single scatter plot.\n\n### 2D clustering result visualization\n\n*)\n\n\n//to create a chart with two dimensional data use the following function\n    \nlet chartCluster2D = \n    result2D.Clusterlist\n    |\u003E Seq.mapi (fun i l -\u003E\n        l\n        |\u003E Seq.map (fun x -\u003E x.[0],x.[1])\n        |\u003E Seq.distinct //more efficient visualization; no difference in plot but in point numbers\n        |\u003E Chart.Point\n        |\u003E Chart.withTraceName (sprintf \u0022Cluster %i\u0022 i))\n    |\u003E Chart.Combine\n\nlet chartNoise2D = \n    result2D.Noisepoints\n    |\u003E Seq.map (fun x -\u003E x.[0],x.[1])  \n    |\u003E Seq.distinct //more efficient visualization; no difference in plot but in point numbers\n    |\u003E Chart.Point\n    |\u003E Chart.withTraceName \u0022Noise\u0022\n\nlet chartTitle2D = \n    let noiseCount   = result2D.Noisepoints |\u003E Seq.length\n    let clusterCount = result2D.Clusterlist |\u003E Seq.length\n    let clPtsCount   = result2D.Clusterlist |\u003E Seq.sumBy Seq.length\n    $\u0022eps: %.1f{eps2D} minPts: %i{minPts} pts: %i{noiseCount \u002B clPtsCount} cluster: %i{clusterCount} noisePts: %i{noiseCount}\u0022 \n\nlet chart2D =\n    [chartNoise2D;chartCluster2D]\n    |\u003E Chart.Combine\n    |\u003E Chart.withTitle chartTitle2D\n    |\u003E Chart.withX_AxisStyle header2D.[0]\n    |\u003E Chart.withY_AxisStyle header2D.[1]\n(**\n\u003Ccenter\u003E\n*)\n(*** condition: ipynb ***)\n#if IPYNB\nchart2D\n#endif // IPYNB\n\n(***hide***)\nchart2D |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\n\u003C/center\u003E\n\n\n### 3D clustering result visualization\n\n\n\n*)\n\n\nlet chartCluster3D = \n    result3D.Clusterlist\n    |\u003E Seq.mapi (fun i l -\u003E\n        l\n        |\u003E Seq.map (fun x -\u003E x.[0],x.[1],x.[2])\n        |\u003E Seq.distinct //faster visualization; no difference in plot but in point number\n        |\u003E fun x -\u003E Chart.Scatter3d (x,StyleParam.Mode.Markers)\n        |\u003E Chart.withTraceName (sprintf \u0022Cluster_%i\u0022 i))\n    |\u003E Chart.Combine\n\nlet chartNoise3D =\n    result3D.Noisepoints\n    |\u003E Seq.map (fun x -\u003E x.[0],x.[1],x.[2])  \n    |\u003E Seq.distinct //faster visualization; no difference in plot but in point number\n    |\u003E fun x -\u003E Chart.Scatter3d (x,StyleParam.Mode.Markers)\n    |\u003E Chart.withTraceName \u0022Noise\u0022\n\nlet chartname3D = \n    let noiseCount   = result3D.Noisepoints |\u003E Seq.length\n    let clusterCount = result3D.Clusterlist |\u003E Seq.length\n    let clPtsCount   = result3D.Clusterlist |\u003E Seq.sumBy Seq.length\n    $\u0022eps: %.1f{eps3D} minPts: %i{minPts} pts: %i{noiseCount \u002B clPtsCount} cluster: %i{clusterCount} noisePts: %i{noiseCount}\u0022 \n   \nlet chart3D = \n    [chartNoise3D;chartCluster3D]\n    |\u003E Chart.Combine\n    |\u003E Chart.withTitle chartname3D\n    |\u003E Chart.withX_AxisStyle header3D.[0]\n    |\u003E Chart.withY_AxisStyle header3D.[1]\n    |\u003E Chart.withZ_AxisStyle header3D.[2]\n    \n//for faster computation you can use the squaredEuclidean distance and set your eps to its square\nlet clusteredChart3D() = DbScan.compute DistanceMetrics.Array.euclideanNaNSquared 20 (0.7**2.) data3D \n(**\n\u003Ccenter\u003E\n*)\n(*** condition: ipynb ***)\n#if IPYNB\nchart3D\n#endif // IPYNB\n\n(***hide***)\nchart3D |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\n\u003C/center\u003E\n\n## Limitations\n\n  1. The selection of minPts and eps is critical and even small deviations can severely influence the final results\n  2. When data points are of varying density, DBSCAN is not appropriate\n\n## Notes\n\n  - Please note that depending on what data you want to cluster, a column wise z-score normalization may be required. In the presented example differences in sepal width have a reduced influence because\n  the absolute variation is low.\n\n## References\n\n  - FSharp.Stats documentation, fslaborg, https://fslab.org/FSharp.Stats/Clustering.html\n  - Shinde and Sankhe, Comparison of Enhanced DBSCAN Algorithms: A Review, International Journal of Engeneering Research \u0026 Technology, 2017\n  - Nagaraju et al., An effective density based approach to detect complex data clusters using notion of neighborhood difference, Int. J. Autom. Comput., 2017, https://doi.org/10.1007/s11633-016-1038-7 \n\n*)\n\n"},{"uri":"https://fslab.org/001_getting-started.html","title":"Getting started\n","content":"(***hide***)\n\n(*\n#frontmatter\n---\ntitle: Getting started\ncategory: datascience\nauthors: David Zimmer\nindex: 0\n---\n*)\n\n(***condition:prepare***)\n#r \u0022nuget: Deedle\u0022\n#r \u0022nuget: FSharp.Stats\u0022\n#r \u0022nuget: Newtonsoft.JSON\u0022\n#r \u0022nuget: Plotly.NET, 2.0.0-preview.6\u0022\n#r \u0022nuget: FSharp.Data\u0022\n\n(***condition:ipynb***)\n#if IPYNB\n#r \u0022nuget: Deedle\u0022\n#r \u0022nuget: FSharp.Stats\u0022\n#r \u0022nuget: Newtonsoft.JSON\u0022\n#r \u0022nuget: Plotly.NET, 2.0.0-preview.6\u0022\n#r \u0022nuget: Plotly.NET.Interactive, 2.0.0-preview.6\u0022\n#r \u0022nuget: FSharp.Data\u0022\n#endif // IPYNB\n\n(**\n\n[![Binder]({{root}}images/badge-binder.svg)](https://mybinder.org/v2/gh/fslaborg/fslaborg.github.io/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script]({{root}}images/badge-script.svg)]({{root}}content/tutorials/{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook]({{root}}images/badge-notebook.svg)]({{root}}content/tutorials/{{fsdocs-source-basename}}.ipynb)\n\n# Getting started\n\nGlad to see you here! Now that you found out and learned about FsLab, this section aims to illustrate how FsLab packages synergize and can be used to tackle\npractical data science challenges. Note that every package used througout the tutorial has its own documentation so if you are interested in Deedle (link), FSharp.Stats or Plotly.Net feel free to take a deeper dive.\n\n## Referencing packages\n\nFsLab is a meant to be a project incubation space and can be thought of as a safe heaven for both, package developers and package users by providing guidelines and tutorials. Packages provided by the community can be used on their own, in combination with other FsLab packages but also in combination with any other .netstandard 2.0 compatible package. From F# 5.0 on packages can be referenced using the following notation:\n\n\u0060\u0060\u0060fsharp\n// Packages hosted by the Fslab community\n#r \u0022nuget: Deedle\u0022\n#r \u0022nuget: FSharp.Stats\u0022\n// third party .net packages \n#r \u0022nuget: Plotly.NET, 2.0.0-preview.6\u0022\n#r \u0022nuget: Plotly.NET.Interactive, 2.0.0-preview.6\u0022\n#r \u0022nuget: FSharp.Data\u0022\n\u0060\u0060\u0060\n\nafter referencing the packages one can access their namespaces and use provided functions. In the following example we will reference the\ntop level namespaces and then use a function provided by the FSharp.Stats package to calculate a factorial:\n*)\nopen FSharp.Stats\n\nlet factorialOf3 = SpecialFunctions.Factorial.factorial 3\n\n(*** condition: ipynb ***)\n#if IPYNB\nfactorialOf3\n#endif // IPYNB\n\n(***include-value:factorialOf3***)\n\n(**\n## Data access\nEquipped with these packages we are now ready to tackle promises made in the first paragraph: solving a practical data science problem. We will start by retrieving the data using the FSharp.Data package, subsequently we will use Deedle (link), a powerful data frame library that makes tabular data accessible by data frame programming. (Note that the chosen names give insight on their type, however thanks to FSharp being a strongly typed language and the we can at any time hower over single values to see the assigned type.)\n*)\nopen FSharp.Data\nopen Deedle\n\n// Retrieve data using the FSharp.Data package\nlet rawData = Http.RequestString @\u0022https://raw.githubusercontent.com/dotnet/machinelearning/master/test/data/housing.txt\u0022\n\n// And create a data frame object using the ReadCsvString method provided by Deedle.\n// Note: Of course you can directly provide the path to a local source.\nlet df = Frame.ReadCsvString(rawData,hasHeaders=true,separators=\u0022\\t\u0022)\n\n// Using the Print() method, we can use the Deedle pretty printer to have a look at the data set.\ndf.Print()\n\n(*** include-output ***)\n\n(**\n## Data crunching\nThe data set of choice is the boston housing data set. As you can see from analyzing the printed output, it consists of 506 rows. Each row represents a house in the boston city area and each column encodes a feature/variable, such as the number of rooms per dwelling (RoomsPerDwelling), Median value of owner-occupied homes in $1000\u0027s (MedianHomeValue) and even variables indicating if the house is bordering river charles (CharlesRiver, value = 1) or not (CharlesRiver, value = 0). \n\nLets say in our analysis we are only interested in the variables just described, furthermore we only want to keep rows where the value of the indicator variable is 0. We can use Deedle to easily create a new frame that fullfills our criteria. In this example we also cast the value of the column \u0022CharlesRiver\u0022 to be of type bool, this illustrates how data frame programming can become typesafe using deedle.\n*)\n\nlet housesNotAtRiver = \n    df\n    |\u003E Frame.sliceCols [\u0022RoomsPerDwelling\u0022;\u0022MedianHomeValue\u0022;\u0022CharlesRiver\u0022]\n    |\u003E Frame.filterRowValues (fun s -\u003E s.GetAs\u003Cbool\u003E(\u0022CharlesRiver\u0022) |\u003E not ) \n\n//sprintf \u0022The new frame does now contain: %i rows and %i columns\u0022 housesNotAtRiver.RowCount housesNotAtRiver.ColumnCount\n\nhousesNotAtRiver.Print()\n\n(*** include-output ***)\n\n(**\n## Data exploration\n\nExploratory data analysis is an approach favored by many - to meet this demand we strongly advertise the use of Plotly.Net. The following snippet illustrates how we can access a column of a data frame and create an interactive chart in no time. Since we might want an idea of the distribution of the house prices a histogram can come in handy: \n*)\nopen Plotly.NET\n\n// Note that we explicitly specify that we want to work with the values as floats. \n// Since the row identity is not needed anymore when plotting the distribution we can\n// directly convert the collection to a FSharp Sequence. \nlet pricesNotAtRiver : seq\u003Cfloat\u003E = \n    housesNotAtRiver\n    |\u003E Frame.getCol \u0022MedianHomeValue\u0022\n    |\u003E Series.values\n    \nlet h1 = \n    Chart.Histogram(pricesNotAtRiver)\n    |\u003E Chart.withX_AxisStyle(\u0022median value of owner occupied homes in 1000s\u0022)\n    |\u003E Chart.withX_AxisStyle(\u0022price distribution\u0022)\n\n(*** condition: ipynb ***)\n#if IPYNB\nh1\n#endif // IPYNB\n\n(***hide***)\nh1 |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\nSince plotly charts are interactive they invite us to combine mutliple charts. Let repeat the filter step and see if houses that are located at the river show a similar distribution:\n*)\n\nlet housesAtRiver = \n    df\n    |\u003E Frame.sliceCols [\u0022RoomsPerDwelling\u0022;\u0022MedianHomeValue\u0022;\u0022CharlesRiver\u0022]\n    |\u003E Frame.filterRowValues (fun s -\u003E s.GetAs\u003Cbool\u003E(\u0022CharlesRiver\u0022))\n\nlet pricesAtRiver : seq\u003Cfloat\u003E = \n    housesAtRiver\n    |\u003E Frame.getCol \u0022MedianHomeValue\u0022\n    |\u003E Series.values\n\nlet h2 =     \n    [\n    Chart.Histogram(pricesNotAtRiver)\n    |\u003E Chart.withTraceName \u0022not at river\u0022\n    Chart.Histogram(pricesAtRiver)\n    |\u003E Chart.withTraceName \u0022at river\u0022\n    ]\n    |\u003E Chart.Combine\n    |\u003E Chart.withX_AxisStyle(\u0022median value of owner occupied homes in 1000s\u0022)\n    |\u003E Chart.withX_AxisStyle(\u0022Comparison of price distributions\u0022)\n\n(***hide***)\nh2 |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\nThe interactive chart allows us to compare the distributions directly. We can now reconstruct our own idea of the city of boston, the sampled area, just by looking at the data e.g.:\n\nAssuming that the sampling process was homogenous while observing that there are much more houses sampled that are not located on the riverside could indicate that a spot on the river is a scarce commodity.\nThis could also be backed by analyzing the tails of the distribution: it seems that houses located at the river are given a head-start in their assigned value - the distribution of the riverside houses is truncated on the left. \n\nSuppose we would have a customer that wants two models, one to predict the prices of a house at the riverside and one that predicts the prices if this is not the case, then we can meet this demand by using FSharp.Stats in combination with Deedle. Of course we need a variable that is indicative of the house price, in this we will check if the number of rooms per dwelling correlates with the house value:\n*)\n\nlet pricesAll :Series\u003Cint,float\u003E = \n    df\n    |\u003E Frame.getCol \u0022MedianHomeValue\u0022\n\nlet roomsPerDwellingAll :Series\u003Cint,float\u003E = \n    df\n    |\u003E Frame.getCol \u0022RoomsPerDwelling\u0022   \n\nlet correlation = \n    let tmpPrices,tmpRooms = \n        Series.zipInner pricesAll roomsPerDwellingAll    \n        |\u003E Series.values \n        |\u003E Seq.unzip\n    Correlation.Seq.pearson tmpPrices tmpRooms\n                                              \n(***include-value:correlation***)\n\n(**\nSo indeed, the number of rooms per dwelling shows a positiv correlation with the house prices. With a pearson correlation of ~0.7 it does not explain the house prices completely - but this is nothing that really surprises us, as one of our hypothesis is that the location (e.g. riverside) does also have influence on the price -  however, it should be sufficient to create a linear model. \n\nSo now we will use FSharp.Stats to build the two linear models ordered by the hypothetical customer. We start by defining a function that performs the fitting and plots the result:\n*)\n\nopen Fitting.LinearRegression.OrdinaryLeastSquares\n\nlet predictPricesByRooms description data = \n    let pricesAll :Series\u003C_,float\u003E = \n        data\n        |\u003E Frame.getCol \u0022MedianHomeValue\u0022\n\n    let roomsPerDwellingAll :Series\u003C_,float\u003E = \n        data\n        |\u003E Frame.getCol \u0022RoomsPerDwelling\u0022   \n\n    let fit = \n        let tmpRooms, tmpPrices = \n            Series.zipInner roomsPerDwellingAll pricesAll    \n            |\u003E Series.sortBy fst\n            |\u003E Series.values \n            |\u003E Seq.unzip\n        let coeffs = Linear.Univariable.coefficient (vector tmpRooms) (vector tmpPrices)\n        let model  = Linear.Univariable.fit coeffs \n        let predictedPrices = tmpRooms |\u003E Seq.map model\n        [\n        Chart.Point(tmpRooms,tmpPrices)\n        |\u003E Chart.withTraceName (sprintf \u0022%s: data\u0022 description )\n        Chart.Line(tmpRooms,predictedPrices)\n        |\u003E Chart.withTraceName (sprintf \u0022%s: coefficients: intercept:%f, slope:%f\u0022 description coeffs.[0] coeffs.[1])\n        ]                                  \n        |\u003E Chart.Combine\n        |\u003E Chart.withX_AxisStyle(\u0022rooms per dwelling\u0022)\n        |\u003E Chart.withY_AxisStyle(\u0022median value\u0022)\n    fit   \n\n(**\nAfterwards, we can apply the function on our prepared datasets and have a look at the model and especially the model coefficients. \n*)\nlet modelVis = \n    [\n    predictPricesByRooms \u0022not at river\u0022 housesNotAtRiver\n    predictPricesByRooms \u0022at river\u0022 housesAtRiver\n    ]\n    |\u003E Chart.Combine\n    |\u003E Chart.withSize(1200.,700.)\n\n(***hide***)\nmodelVis |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n\n(**\nBoth models approximate the data in a reasonable way. When we inspect the coefficients, we see that the models only differ slightly in slope, but have an absolute offset of ~7.5. This observation complements the insights gained by the explorative data analysis approach using the histogram! \n*)"},{"uri":"https://fslab.org/index.html","title":"The fslab documentation template\n","content":"(***hide***)\n\n(*\n#frontmatter\n---\ntitle: -\ncategory: hidden\nauthors: -\nindex: 0\n---\n*)\n\n(**\n# The fslab documentation template\n\nThis template scaffolds the necessary folder structure for FSharp.Formatting \nand adds custom styles in the **fslab** theme. \n\nThe provided stylesheet was compiled from sass (before uploading the nuget package) and\nuses the [Bulma](https://bulma.io/) CSS framework instead of bootstrap which is used by FSharp.Formatting per default.\n\n#### Table of contents \n\n- [Installation](#Installation)\n- [Usage](#Usage)\n- [Quick content rundown](#Quick-content-rundown)\n- [Creating new content](#Creating-new-content)\n- [Customization options](#Customization-options)\n    - [Style sheet options](#Style-sheet-options)\n    - [Inclusion of sample content](#Inclusion-of-sample-content)\n    - [Create notebooks](#Create-notebooks)\n\n\n## Installation\n\nThis template is available as a _dotnet new_ template (from [nuget](https://www.nuget.org/packages/FsLab.DocumentationTemplate/)):\n\n\u0060\u0060\u0060no-highlight\ndotnet new -i FsLab.DocumentationTemplate\n\u0060\u0060\u0060\n\n## Usage\n\nIf not already present, create a _local tool manifest_ in the root of your project that you want to write documentation for:\n\n\u0060\u0060\u0060no-highlight\ndotnet new tool-manifest\n\u0060\u0060\u0060\n\nThen, still in the root of your project, run:\n\n\u0060\u0060\u0060no-highlight\ndotnet new fslab-docs\n\u0060\u0060\u0060\n\n## Quick content rundown:\n\nThe default template initializes the following folder structure when you initialize it in the root of your project.\n\nSee [further below](#Customization-options) for command line customization options of the template.\n\n\u003Cpre\u003E\ndocs\n\u2502   index.fsx\n\u2502   _template.html\n|   _template.ipynb\n|   \n\u2502   0_Markdown-Cheatsheet.md\n\u2502   1_fsharp-code-example.fsx\n\u2502   2_inline-references.fsx\n\u2502   3_notebooks.fsx\n|\n\u251C\u2500\u2500\u2500content\n\u2502   fsdocs-custom.css\n\u2502\n\u251C\u2500\u2500\u2500img\n\u2502       favicon.ico\n\u2502       logo.png\n\u2502\n\u2514\u2500\u2500\u2500reference\n        _template.html\n\u003C/pre\u003E\n\n- \u0060index.fsx\u0060 is the file you are reading just now. It contains the very content you are reading at the moment \nin a markdown block indicated by \u0060(** *)\u0060 guards. It will be rendered as the root \u0060index.html\u0060 file of your documentation.\n\n- \u0060_template.html\u0060 is the root html scaffold (sidebar to the left, script and style loading) where all of the individual docs will be injected into\n\n- \u00600_Markdown-Cheatsheet.md\u0060 is a adaption of [this markdown cheat sheet](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet) that shows how to write markdown and showcases the rendered equivalents. It can also be viewed in all its glory [here](https://fslab.org/docs-template/0_Markdown-Cheatsheet.html).\n\n- \u00601_fsharp-code-example.fsx\u0060 is a script file that showcases the syntax highlighting style for F# snippets. It can also be viewed in all its glory [here](https://fslab.org/docs-template/1_fsharp-code-example.html).\n\n- \u00602_inline-references.fsx\u0060 is a script file that explains how to use inline references and use Plotly.NET for charting. It can also be viewed in all its glory [here](https://fslab.org/docs-template/2_inline-references.html).\n\n- \u00603_notebooks.fsx\u0060 is a script file that showcases conditional content in documentation and how to use that to create dotnet interactive notebooks besides your html documentation. It can also be viewed in all its glory [here](https://fslab.org/docs-template/3_notebooks.html).\n\n- \u0060fsdocs-custom.css\u0060 contains the custom styling that applies the fslab styles.\n\n - the \u0060img\u0060 folder contains the fslab logo and favicon. replace these files (with the same names) to youse sours\n\n - \u0060reference/_template.html\u0060 is a slightly adapted version of the template above for the API documentation\n\n## Creating new content\n\n- run \u0060dotnet fsdocs watch --eval\u0060 to spawn a watcher and dev server that hosts your docs on http://localhost:8901/ (You currently will still have to refresh the page when you make changes to files)\n\n- add a new .md or .fsx file to the \u0060content\u0060 directory (or into a new subdirectory there)\n\n- the sidebar title for the document will be either the file name or, if existent, the first level 1 header in the file\n\n- when writing a .fsx file, code will automatically become syntax-highlighted code snippets. \n\n- use \u0060(** \u003Cmarkdown here\u003E *)\u0060 to guard markdown sections in .fsx files\n\n- use \u0060(*** include-value:\u003Cval name\u003E ***)\u0060 to include the value of a binding\n\n- use \u0060(*** include-it ***)\u0060 to include the evaluation of the previous snippet block \n\nFor more info please refer to the [FSharp.Formatting documentation](http://fsprojects.github.io/FSharp.Formatting/).\n\n\n## Customization options\n\n### Style sheet options\n\n\u0060\u0060\u0060no-highlight\n-s|--styles             Set the type of style content the template will initialize. For the sass file to work, you will have to download bulma\n\n        all             - sass file, compiled csss, and minified css\n\n        sass            - only include the sass file\n\n        minified        - only include the minified css file\n\n        css             - only include the compiled css file\n\n        Default:        css\n\u0060\u0060\u0060\n\n### Inclusion of sample content\n\n\u0060\u0060\u0060no-highlight\n-is|--include-samples   wether to include sample files in the generated content\n\n        bool            - Optional\n\n        Default:        true\n\u0060\u0060\u0060\n\n### Create notebooks\n\n\u0060\u0060\u0060no-highlight\n-in|--include-notebooks  wether to include the notebook template file\n        \n        bool            - Optional\n\n        Default:        true\n\u0060\u0060\u0060\n\n*)\n"}]